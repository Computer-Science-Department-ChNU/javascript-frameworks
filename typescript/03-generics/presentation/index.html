<!DOCTYPE html>
<html lang="uk">
<head>
    <title>TypeScript Fundamentals</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <link rel="stylesheet" href="../../../core/styles/styles.css">
    <style>
        .shower {
            --slide-ratio: calc(16 / 9);
        }
    </style>
</head>
<body class="shower list">

<header class="caption">
    <h1>TypeScript Fundamentals</h1>
</header>

<section class="slide">
    <h2>Лекція 3. Generics</h2>
    <h3>План лекції:</h3>
    <ol>
        <li>Generic або узагальнені типи</li>
        <li>Використання обмежень в узагальнених типах</li>
    </ol>
</section>

<section class="slide">
    <h2>Generics: загальні поняття</h2>
    <p>
        Уявіть величезний і дорогий, високотехнологічний друкарський друкарський верстат, виконаний у вигляді моноліту,
        що, своєю чергою, робить його придатним для друку тільки одного номера газети. Тобто для друку сьогоднішніх
        новин необхідний один друкарський верстат, для завтрашніх - інший і т.д. Подібний верстат можна порівняти зі
        звичайним типом, ознаки якого після оголошення залишаються незмінними при його реалізації. Інакше кажучи, якщо
        за існування типу A, опис якого містить поле, що належить до типу number, знадобиться тип, відмінність якого
        складатиметься лише в приналежності поля до іншого типу, виникне необхідність у його оголошенні.
    </p>
</section>

<section class="slide">
    <h2>Generics: загальні поняття</h2>
    <img src="pictures/3.png" alt="" width="500">
    <p>Узагальнене програмування (Generic Programming) - це підхід, за якого алгоритми можуть однаково працювати з
        даними, що належать до різних типів даних, без зміни декларації (опису типу).</p>
</section>

<section class="slide">
    <h2>Generics: загальні поняття</h2>
    <p>В основі узагальненого програмування лежить таке ключове поняття як узагальнення. <b>Узагальнення (Generics)</b>
        - це
        параметризований тип, що дає змогу оголошувати параметри типу, які є тимчасовою заміною конкретних типів,
        конкретизація яких буде виконана в момент створення екземпляра. Параметри типу, за умови дотримання деяких
        правил, можна використовувати в більшості операцій, що допускають роботу зі звичайними типами. Усе це разом дає
        привід порівнювати узагальнений тип із правильною версією друкарського верстата, чи заміні валу, призначеного
        для друкування інформації на папері, який проходить через них, можна порівняти з параметрами типу.</p>
</section>

<section class="slide">
    <h2>Generics: загальні поняття</h2>
    <p>У реальності узагальнення дають змогу скорочувати кількість перетворень (приведень) і писати багаторазово
        використовуваний код, водночас підвищуючи його типобезпеку.</p>
    <p>Цих прикладів має бути достатньо для утворення виразного образу узагальнень. Але, перш ніж продовжити, варто
        уточнити значення таких далеко не всім очевидних термінів, як - <b>узагальнений тип, параметризований тип і
            універсальна конструкція</b>.</p>
</section>

<section class="slide">
    <h2>Generics: загальні поняття</h2>
    <p><b>Тип</b>, що визначає параметр, позначається як <b>узагальнений тип</b>.
        Під час обговорення типів, що представляються параметрами типу, необхідно розуміти, що вони визначені в <b>параметризованому
            типі</b>. Коли <b>оголошення узагальненого типу отримало реалізацію</b>, то таку конструкцію, чи то клас, чи
        то функція, називають
        <b>універсальною (універсальний клас, універсальна функція або метод).</b></p>
</section>

<section class="slide">
    <h2>Generics: загальні поняття</h2>
    <p><b>Generic</b> (узагальнений тип або шаблон) – спеціальний тип даних, який дозволяє створювати компоненти,
        не прив'язуючись до конкретного типу даних, а вказувати цей тип даних під час створення компонента</p>
    <img src="pictures/1.png" alt="">
</section>

<section class="slide">
    <h2>Generics: загальні поняття</h2>
    <img src="pictures/2.png" alt="" width="800">
</section>

<section class="slide">
    <h2>Generics: загальні поняття</h2>
    <p>У TypeScript Generics можуть бути вказані для типів, що визначаються за допомогою:</p>
    <ul>
        <li>псевдонімів (type)</li>
        <li>інтерфейсів, оголошених за допомогою ключового слова interface</li>
        <li>класів (class), зокрема класових виразів (class expression)</li>
        <li>функцій (function), визначених у вигляді як декларацій (Function Declaration), так і виразів (Function
            Expression)
        </li>
        <li>методів (method)</li>
    </ul>
</section>

<section class="slide">
    <h2>Generics: загальні поняття</h2>
    <p>Generics оголошуються за допомогою пари кутових дужок, у які через кому поміщено параметри типу, звані також <b>типо-заповнювачами
        або універсальними параметрами</b> <code>Type&lt;T0, T1&gt;</code></p>
    <img src="pictures/4.png" alt="" width="400">
</section>

<section class="slide">
    <h2>Generics: загальні поняття</h2>
    <p>
        Параметри типу можуть бути вказані як тип скрізь, де потрібна анотація типу. Область видимості параметрів типу
        обмежена областю узагальненого типу. Усі входження параметрів типу будуть замінені на конкретні типи, передані
        як аргументи типу. Аргументи типу вказуються в кутових дужках, в яких через кому вказуються конкретні типи даних
        <code>Type&lt;number, string&gt;</code>.
    </p>
</section>

<section class="slide">
    <h2>Generics: загальні поняття</h2>
    <img src="pictures/5.png" alt="" width="350">
</section>

<section class="slide">
    <h2>Generics: ідентифікатори параметрів</h2>
    <div style="font-size: 18px;">
        <p>
            Ідентифікатори параметрів типу повинні починатися з великої літери і, крім фантазії розробника, вони також
            обмежені загальними для TypeScript правилами. Якщо логічну приналежність параметра типу можна встановити без
            жодних зусиль, як, наприклад, у випадку Array&lt;T&gt;, який кричить, що параметр типу T представляє тип, до
            якого можуть належати елементи цього масиву, то ідентифікатори параметрів типу заведено обирати з
            послідовності
            T, S, U, V і т. д. Також часта послідовність T, U, V, V, S тощо.
        </p>
        <p>За допомогою K і V прийнято позначати типи, що відповідають Key/Value, а за допомогою P - Property.
            Ідентифікатором Z прийнято позначати поліморфний тип this.</p>
        <p>
            Крім того, не виключені випадки, в яких краще виглядають повні імена, як, наприклад, RequestService,
            ResponseService, до яких ще можна застосувати <a
                href="https://www.wikidata.uk-ua.nina.az/%D0%A3%D0%B3%D0%BE%D1%80%D1%81%D1%8C%D0%BA%D0%B0_%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D1%96%D1%8F.html"
                target="_blank">Угорську нотацію</a> - TRequestService, TResponseService.
        </p>
    </div>
</section>

<section class="slide">
    <h2>Generics: ідентифікатори параметрів</h2>
    <p>
        Наприклад, побачивши в автодоповненні редактора тип Array&lt;T&gt;, на думку одразу спадає правильний варіант,
        що масив міститиме елементи, які належать до зазначеного типу T. Але, побачивши Animal&lt;T, S&gt;, можна ніколи
        не здогадатися, що ці типи даних будуть вказані в анотації типу полів id і arial. У цьому випадку було б
        набагато краще дати імена Animal&lt;AnimalID, AnimalArial&gt; або навіть Animal&lt;TAnimalID, TAnimalArial&gt;,
        що дасть змогу всередині тіла параметризованого типу Animal відрізняти його параметри типу від конкретних
        оголошень.
    </p>
</section>

<section class="slide">
    <h2>Generics: область видимості параметрів</h2>
    <div class="columns two">
        <div style="font-size: 16px;">
            <p>
                У разі, коли узагальнення вказано псевдоніму типу (type), область видимості параметрів типу обмежена
                самим
                виразом.
            </p>
            <p>
                Область видимості параметрів типу при оголошенні функції та функціонального виразу, включно зі
                стрілочним, а
                також методів, обмежується їхньою сигнатурою і тілом. Іншими словами, параметр типу можна
                використовувати як тип
                при оголошенні параметрів, значення, що повертається, а також у допустимих виразах (анотація типу,
                приведення
                типу тощо), розташованих у тілі.
            </p>
        </div>
        <img src="pictures/6.png" alt="" width="400">
    </div>
</section>

<section class="slide">
    <h2>Generics: область видимості параметрів</h2>
    <div class="columns two">
        <div style="font-size: 16px;">
            Під час оголошення класів (зокрема й класових виразів)
            та інтерфейсів, область видимості параметрів типу обмежується областю оголошення і тілом.
            <br>
            У випадках, коли клас/інтерфейс розширює інший клас/інтерфейс,
            який оголошено як узагальнений, нащадок зобов'язаний вказати типи для свого предка.
            Нащадок як аргумент типу своєму пращуру може вказати не тільки конкретний тип,
            а й тип, представлений власними параметрами типу.
        </div>
        <div>
            <img src="pictures/7.png" alt="" width="200">
            <br>
            <img src="pictures/8.png" alt="" width="400">
        </div>
    </div>
</section>

<section class="slide">
    <h2>Generics</h2>
    <div class="columns two">
        <div style="font-size: 16px;">
            Належність параметра типу до конкретного типу даних
            встановлюється в момент передачі аргументів типу.
            При цьому конкретні типи даних вказуються в парі кутових дужок,
            а кількість конкретних типів має відповідати кількості обов'язкових параметрів типу.
            <br>
            Якщо узагальнений тип вказується як тип даних, то він зобов'язаний містити анотацію
            узагальнення.
        </div>
        <div>
            <img src="pictures/9.png" alt="" width="400">
            <br>
            <img src="pictures/10.png" alt="" width="400">
        </div>
    </div>
</section>

<section class="slide">
    <h2>Generics</h2>
    <div class="columns two">
        <div style="font-size: 16px;">
            Коли всі обов'язкові параметри типу використовуються в параметрах конструктора,
            при створенні екземпляра класу анотацію узагальнення можна опускати.
            У такому разі виведення типів визначить приналежність до типів за встановлюваними значеннями.
            Якщо параметри є необов'язковими і значення не буде передано,
            то виведення типів визначить приналежність параметрів типу до типу даних unknown.
        </div>
        <div>
            <img src="pictures/11.png" alt="" width="400">
        </div>
    </div>
</section>

<section class="slide">
    <h2>Generics: Параметри типу <br> - extends (generic constraints)</h2>

        <div style="font-size: 19px;">
            Крім того, що параметри типу можна вказувати як конкретний тип, вони також можуть розширювати
            інші типи, зокрема й інші параметри типу. Такий механізм потрібен,
            коли значення всередині узагальненого типу повинні мати обмежений набір ознак.
            Ключове слово extends розміщується лівіше розширюваного типу і правіше ідентифікатора параметра
            типу &lt;T extends Type&gt;. Як розширюваний тип може бути вказано як конкретний тип даних,
            так і інший параметр типу. При чому якщо один параметр типу розширює інший,
            немає різниці, в якому порядку вони оголошуються. Якщо параметр типу обмежений іншим параметром типу,
            то таке обмеження називають неприкритим обмеженням типу (naked type constraint),
            <br>
            Механізм розширення потрібен у тих випадках, у яких параметр типу має володіти
            заданими характеристиками, необхідними для виконання конкретних операцій над цим типом.
        </div>

</section>

<section class="slide">
    <h2 class="shout">Дякую за увагу!</h2>
</section>

<div class="progress"></div>

<script src="../../../core/shower.js"></script>
</body>
</html>

