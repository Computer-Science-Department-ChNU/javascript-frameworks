// Змінні, створені з використанням ключового слова var,
// знаходяться у глобальній області видимості або
// локальної області видимості, яка представлена функцією.
// При цьому змінна доступна до її фактичного визначення
// і після будь-якого блоку {}

function var1() {
    console.log(i); // змінна i існує, але значення ще не присвоєно, тому - undefined
    console.log(test); // undefined

    for (var i = 0; i < 10; i++) { // ініціалізація i
        var test = i; // пере присвоєння змінних; область видимості для test - вся функція var1 з точки зору js
    } // hoisting

    console.log(i); // 10
    console.log(test); // 9
}

var1();

// Повторне визначення змінної не призводить до помилки.
function var2() {
    var a = 10;
    var a = 20;
    console.log(a); // 20
}

var2();

// такий цикл виведе на екран 5, 5, 5, 5, 5
// замість очікуваних 0, 1, 2, 3, 4
// Щоразу, коли викликалася функція setTimeout їй
// передавалося посилання на одну й ту саму змінну з
// області видимості функції var3, тому всі виклики
// setTimeout у результаті використовували одне значення

// var i має функціональну область видимості, а не блочну (як у let).
// Це означає, що у циклі всі ітерації спільно використовують одну й ту ж змінну i.
// цикл for виконається дуже швидко (синхронно) - i пробіжить значеннями 0, 1, 2, 3, 4, і вийде з циклу, коли i === 5
// setTimeout(...) відкладає виконання функцій з console.log у чергу подій. Вони виконаються після завершення циклу.
// коли дійде черга виконувати console.log(i), змінна i вже дорівнюватиме 5 (останнє значення після виходу з циклу)
function var3() {
    for (var i = 0; i < 5; i++) {
        setTimeout(function () { // асинхронний код
            console.log(i);
        }, 10);
    }
}

var3();

// Мова йде про замикання (closure):
// У випадку з var усі колбеки замкнулися на одну спільну змінну i.
// У випадку з let кожна ітерація створила нову змінну i, і замикання колбеків вказують на різні змінні.