<!DOCTYPE html>
<html lang="uk">
<head>
    <title>Vue.js</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <link rel="stylesheet" href="../../../core/styles/styles.css">
    <style>
        .shower {
            --slide-ratio: calc(16 / 9);
        }
    </style>
</head>
<body class="shower list">

<header class="caption">
    <h1>Маршрутизація у Vue.js</h1>
</header>

<section class="slide">
    <h2>Лекція 10. Маршрутизація у Vue.js</h2>
    <h3>План лекції:</h3>
    <div class="columns two">
        <ol>
            <li>Як працює маршрутизація в SPA.</li>
            <li>Встановлення та налаштування vue-router.</li>
            <li>Методи vue-router.</li>
            <li>Приклад роботи роутингу vue-router.</li>
        </ol>
        <img src="pictures/1.jpg" alt="" width="251">
    </div>
</section>

<section class="slide">
    <h2>Як працює маршрутизація в SPA</h2>
    <p><b>Маршрутизація (routing)</b> — це процес зіставлення URL-адрес із різними представленнями (view) чи
        компонентами у вашій програмі (застосунку), що дозволяє
        користувачам переходити між різними
        сторінками чи розділами вашої програми (застосунку) без
        необхідності повного перезавантаження
        сторінки.</p>
    <p>
        У Vue 3 маршрутизація на стороні клієнта
        обробляється бібліотекою <a href="https://github.com/vuejs/router" target="_blank">vue-router</a>.
    </p>
    <p>
        <b>vue-router</b> надає спосіб зіставляти URL-шляхи з
        різними компонентами у вашій програмі (застосунку)
        Vue, дозволяючи вам створювати
        односторінкові застосунки (SPA) із
        кількома представленнями (view).
    </p>
</section>

<section class="slide">
    <h2>Як працює маршрутизація в SPA</h2>
    <div class="columns two" style="font-size: 17px;">
        <div>
            <h3>Server-Side Routing</h3>
            <p>
                Маршрутизація на стороні
                сервера означає, що сервер
                надсилає відповідь на основі
                URL-шляху, який відвідує
                користувач. Коли ми клацаємо
                посилання в традиційній вебпрограмі, що відтворюється на
                сервері, браузер отримує
                відповідь HTML від сервера та
                перезавантажує всю сторінку з
                новим HTML.
            </p>
        </div>
        <div>
            <h3>Client-Side Routing</h3>
            <p>
                Проте в односторінковій програмі (SPA)
                клієнтський JavaScript може
                перехоплювати навігацію, динамічно
                отримувати нові дані та оновлювати
                поточну сторінку без повного
                перезавантаження сторінки.
                <br>
                Це зазвичай призводить до більш швидкої
                взаємодії з користувачем, особливо для
                випадків використання, які більше схожі
                на справжні «застосунки», де користувач
                повинен виконувати багато взаємодій
                протягом тривалого періоду часу.
            </p>
        </div>
    </div>
</section>

<section class="slide">
    <h2>Як працює маршрутизація в SPA</h2>
    <p>
        У таких одно-сторінкових додатках, "маршрутизація" відбувається на стороні клієнта, в браузері. Маршрутизатор на
        стороні клієнта відповідає за керування відрендереним виглядом програми за допомогою API браузера, наприклад
        <a href="https://developer.mozilla.org/ru/docs/Web/API/History" target="_blank">API історії</a> або події
        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event"
           target="_blank">hashchange</a>.
    </p>
    <p>Якщо потрібна дуже проста маршрутизація і немає необхідності хочете використовувати повноцінну бібліотеку, то
        можна це зробити за допомогою динамічних компонентів і оновлювати поточний стан компонента прослуховуючи подію
        hashchange або використовуючи API історії (Приклад:
        vue-example/src/components/SimpleRouting/SimpleRouting.vue).</p>
</section>

<section class="slide">
    <h2>Встановлення та налаштування vue-router.</h2>
    <p></p>
    <ol>
        <li>Встановлення vue-router: <a href="https://router.vuejs.org/installation.html">documentation</a></li>
        <li>Створення екземпляру маршрутизатора (vue-example/src/router/index.ts)</li>
        <li>Підключення маршрутизатора: імпорт маршрутизатора, додавання його до кореневого екземпляра Vue
            (vue-example/src/main.ts)
        </li>
        <li>Використовуємо компонент <code>&lt;router-view&gt</code> в App.vue для відображення
            компонентів в залежності від
            маршруту
        </li>
        <li>
            Використовуємо компонент <code>&lt;router-link&gt</code> для переходу між маршрутами.
        </li>
        <li>Налаштування додаткових опцій: переадресація (redirects), якщо потрібно налаштувати переадресацію на
            інший маршрут
        </li>
        <li>
            Обробка 404 сторінки (NotFound)
        </li>
    </ol>
</section>

<section class="slide">
    <h2>Встановлення та налаштування vue-router.</h2>
    <p>
        На додачу до відображення URL-шляхів
        до компонентів, vue-router також підтримує:
    </p>
    <ul>
        <li>параметри маршруту</li>
        <li>вкладені маршрути</li>
        <li>захист маршрутів, що дозволяють
            контролювати доступ до різних частин
            вашої програми на основі автентифікації
            користувача чи інших факторів.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Методи vue-router</h2>
    <p>Бібліотека vue-router
        надає кілька методів, які
        дозволяють вам
        переходити між різними
        маршрутами у застосунку.</p>
    <p><b style="color: orangered">router.push(location, onComplete?, onAbort?)</b>: надсилає
        новий маршрут до стеку історії та здійснює навігацію до нього.</p>
    <p>
        Параметром розташування може бути рядок, що представляє шлях
        нового маршруту, або об’єкт із такими властивостями, як ім’я,
        параметри та запит.
    </p>
    <p>
        Ви також можете надати необов’язкові зворотні виклики onComplete
        і onAbort, які будуть викликані, коли навігація буде успішною або
        невдалою відповідно.
    </p>
</section>

<section class="slide">
    <h2>Методи vue-router</h2>
    <p>
        <b style="color: orangered">router.replace(location, onComplete?, onAbort?)</b>:
        замінює поточний маршрут у стеку історії новим маршрутом і
        здійснює навігацію до нього. Параметри такі ж, як і для router.push.
    </p>
    <p>
        <b style="color: orangered">router.go(n)</b>: переходить до маршруту в стеку історії відносно поточного
        маршруту.
        Параметр n може бути додатним або від’ємним цілим числом, що
        представляє кількість кроків, які потрібно пройти вперед або назад в
        історії.
    </p>
    <p>
        <b style="color: orangered">router.back()</b>: еквівалент router.go(-1). Переміщується на крок назад в історії.
    </p>
    <p><b style="color: orangered">router.forward()</b>: еквівалент router.go(1). Переходить на крок вперед в історії.
    </p>
</section>

<section class="slide">
    <h2 class="shout">Дякую за увагу!</h2>
</section>

<div class="progress"></div>

<script src="../../../core/shower.js"></script>
</body>
</html>

