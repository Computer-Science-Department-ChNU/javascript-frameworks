<!DOCTYPE html>
<html lang="uk">
<head>
    <title>Vue.js</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <link rel="stylesheet" href="../../../core/styles/styles.css">
    <style>
        .shower {
            --slide-ratio: calc(16 / 9);
        }
    </style>
</head>
<body class="shower list">

<header class="caption">
    <h1>Axios. Робота з API</h1>
</header>

<section class="slide">
    <h2>Лекція 12. Axios. Робота з API</h2>
    <h3>План лекції:</h3>
    <div class="columns two">
        <ol>
            <li>Що таке Axios?</li>
            <li>Підключення Axios</li>
            <li>Робота з бібліотекою.</li>
        </ol>
        <img src="pictures/1.webp" alt="" width="100%">
    </div>
</section>

<section class="slide">
    <h2>Що таке Axios?</h2>
    <h3>API (Application Programming Interface)</h3>
    <p>Загалом, API - це набір протоколів, процедур та
        інструментів, які дозволяють різним програмним
        програмам спілкуватися та взаємодіяти один з одним.</p>
    <p>
        API забезпечують структурований спосіб програмного
        забезпечення для обміну даними та функціональними
        можливостями. Вони діють як міст між різними
        програмними системами, що дозволяє їм спілкуватися
        та працювати разом. API можна використовувати для
        широкого спектру цілей, включаючи обмін даними,
        управління ресурсами та інтеграцію додатків.
    </p>
</section>

<section class="slide">
    <h2>Що таке Axios?</h2>
    <h3>API in Vue</h3>
    <p>Конкретно у Vue API - це набір правил та
        протоколів, які регулюють те, як
        розробники можуть взаємодіяти та
        використовувати основні функції та
        функціональність Vue</p>
    <p>
        Ці API забезпечують структурований
        спосіб розробникам маніпулювати та
        контролювати поведінку компонентів Vue,
        директив та інших елементів фреймворку.
    </p>
</section>

<section class="slide">
    <h2>Що таке Axios?</h2>
    <p>Існує кілька популярних бібліотек
        JavaScript для виконання HTTP-запитів
        із веббраузерів або Node.js.</p>
    <ul>
        <li>Axios</li>
        <li>Fetch</li>
        <li>Superagent</li>
        <li>Request</li>
    </ul>
</section>

<section class="slide">
    <h2>Що таке Axios?</h2>
    <p>
        <b>Axios</b> — це легка та проста у
        використанні бібліотека для
        створення HTTP-запитів. Він має
        простий та інтуїтивно
        зрозумілий API та надає такі
        функції, як перехоплювачі для
        обробки даних запитів і
        відповідей, а також скасування
        запитів.
    </p>
    <p>
        <b>Fetch</b> — це рідний (нативний)
        JavaScript API для виконання
        HTTP-запитів. Він має простий
        API, який простий у
        використанні та розумінні, і
        забезпечує інтерфейс на основі
        обіцянок для обробки
        відповідей.
    </p>
</section>

<section class="slide">
    <h2>Що таке Axios?</h2>
    <p>
        <b>Superagent</b> — це легка та
        гнучка бібліотека для створення
        HTTP-запитів. Він підтримує
        багато розширених функцій, якот потокові відповіді,
        відстеження прогресу та
        автоматичні повтори.
    </p>
    <p>
        <b>Request</b> — популярна
        бібліотека для створення
        HTTP-запитів у Node.js. Він
        надає багато розширених
        функцій, як-от обробка
        файлів cookie,
        автентифікація OAuth і
        завантаження файлів із
        кількома частинами.
    </p>
    <p>
        Це лише кілька прикладів із багатьох бібліотек,
        доступних для виконання HTTP-запитів у
        JavaScript. Вибір бібліотеки залежить від конкретних
        потреб програми та вподобань розробника.
    </p>
</section>

<section class="slide">
    <h2>Підключення Axios та Робота з бібліотекою.</h2>
    <div class="columns two">
        <div style="font-size: 18px;">
            <p>
                У Vue 3 Axios зазвичай
                використовується для надсилання та
                отримання даних із сервера,
                наприклад, для отримання даних з API
                або надсилання форми до серверної
                кінцевої точки.
            </p>
            <p>Коли запит виконується успішно,
                викликається метод then із даними
                відповіді, які ми призначаємо масиву
                продуктів в об’єкті даних нашого
                компонента.</p>
            <p>Якщо запит завершується невдачею,
                викликається метод catch з помилкою.</p>
        </div>
        <img src="pictures/1.png" alt="" width="100%">
    </div>
</section>

<section class="slide">
    <h2>Робота з бібліотекою.</h2>
    <p>
        У HTTP автентифікація носія (Bearer authentication) —
        це тип автентифікації на основі маркера доступу, у
        якому маркер доступу передається від клієнта до
        сервера в заголовку HTTP, зокрема в заголовку
        авторизації.
    </p>
    <p>Маркери носія (Bearer tokens) часто використовуються
        для автентифікації API, і вони зазвичай видаються
        сервером авторизації в результаті процесу
        автентифікації користувача. Маркер доступу зазвичай
        має обмежений термін служби, і його потрібно
        періодично оновлювати.</p>
</section>

<section class="slide">
    <h2>Робота з бібліотекою.</h2>
    <div style="font-size: 19px;">
        <p>
            Формат токена Bearer — це просто слово «Bearer»,
            після якого йде пробіл, а потім маркер доступу.
        </p>
        <p>Наприклад, Authorization: Bearer
            eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM
            0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE
            2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4f6wkPOdMeJ</p>
        <p>У Vue маркери носія часто використовуються
            для автентифікації запитів HTTP до кінцевих
            точок API, які потребують автентифікації. Під час
            надсилання запиту до кінцевої точки API, яка
            вимагає автентифікації, ви можете включити
            маркер носія в заголовок авторизації запиту,
            використовуючи формат, описаний вище. Це
            дозволяє серверу ідентифікувати користувача,
            пов’язаного з маркером, і авторизувати
            запитану дію.</p>
    </div>
</section>

<section class="slide">
    <h2>Організація шару API</h2>
    <p>Винесення шару API в окремі ендпойнти в Vue додатку має кілька важливих переваг:</p>
    <ul style="font-size: 19px;">
        <li>
            <b>Чітка структура коду.</b> Винесення запитів до API в окремі ендпойнти створює чисту і зрозумілу структуру
            коду, де кожна частина застосунку відповідає за свою функціональність. Компоненти відповідають лише за
            відображення даних, тоді як ендпойнти API обробляють всю взаємодію з сервером.
        </li>
        <li>
            <b>Полегшення тестування.</b> Легше тестувати компонентний і API шари окремо. Наприклад, можна замінити
            справжні API-запити на мок-дані під час тестування компонентів, що робить тестування ефективнішим.
        </li>
        <li>
            <b>Спрощення підтримки й рефакторингу.</b> Якщо API зміниться (нові маршрути, нова структура даних),
            достатньо буде оновити лише шар API, а не шукати зміни по всьому коду. Це зменшує ризик появи помилок.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Організація шару API</h2>
    <p>Винесення шару API в окремі ендпойнти в Vue додатку має кілька важливих переваг:</p>
    <ul style="font-size: 19px;">
        <li>
            <b>Повторне використання логіки. </b>Винесення API запитів в окремий шар дозволяє багаторазово
            використовувати однакову логіку для різних компонентів. Наприклад, різні частини застосунку можуть
            отримувати однакові дані з API, використовуючи спільні функції.
        </li>
        <li>
            <b>Легке управління помилками.</b> В окремому шарі API можна централізовано обробляти помилки, додавати
            логіку повторних спроб або відображати повідомлення про помилку. Це спрощує управління помилками, оскільки
            вони обробляються в одному місці.
        </li>
        <li>
            <b>Підвищення продуктивності.</b> В окремому API-шарі можна реалізувати кешування, об’єднання запитів або
            інші оптимізації, що сприяє швидшій роботі застосунку.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Принципи створення чистої, структурованої архітектури в Vue застосунку.</h2>
    <h3>1 - Винесення API у окремі ендпойнти</h3>
    <p>Це означає створення окремого шару API, який буде відповідати за всю логіку взаємодії з сервером. Для цього
        створюють окремі функції або модулі, які здійснюють запити до API та повертають дані. Зазвичай цей шар називають
        "сервісним" або "шаром API".</p>
    <ul style="font-size: 17px;">
        <li>
            Легкість підтримки. Оскільки всі запити API зосереджені в одному місці, їх легше обслуговувати і
            рефакторити.
        </li>
        <li>
            Централізована обробка помилок. Шар API дозволяє реалізувати єдину логіку для обробки помилок..
        </li>
        <li>
            Кешування й оптимізація. В одному місці можна реалізувати механізми кешування або оптимізації запитів.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Принципи створення чистої, структурованої архітектури в Vue застосунку.</h2>
    <h3>2 - Використання ендпойнтів у store в actions</h3>
    <p>Pinia (Vuex) дозволяє організувати глобальний стан застосунку, що зручно для зберігання та обробки загальних
        даних,
        таких як авторизація, список користувачів тощо. API-запити зазвичай виконуються в actions, оскільки actions
        підтримують асинхронні операції.</p>
    <ul style="font-size: 17px;">
        <li>
            Єдине джерело правди. Дані, отримані від API, доступні через Pinia і можуть використовуватися в будь-якому
            компоненті, що полегшує підтримку узгодженості стану.
        </li>
        <li>
            Логічне розділення. Actions виконують асинхронну логіку.
        </li>
    </ul>
</section>

<section class="slide">
    <h2>Принципи створення чистої, структурованої архітектури в Vue застосунку.</h2>
    <h3>3 - Виклик actions тільки в компонентах</h3>
    <p>Цей принцип означає, що компоненти повинні лише ініціювати дії (викликати actions) для отримання чи оновлення
        даних, а не містити бізнес-логіку. Компонентам слід залишити тільки функції відображення даних і взаємодії з
        користувачем, тоді як логіка отримання даних з API виконується в actions.</p>
    <ul style="font-size: 17px;">
        <li>
            Чистота компонентів. Компоненти стають легкими та орієнтованими на відображення, без бізнес-логіки чи
            запитів.
        </li>
        <li>
            Повторне використання. Один actions може бути використаний у багатьох компонентах, забезпечуючи єдиний
            підхід
            до обробки даних.
        </li>
        <li>
            Контроль над станом. Компоненти не змінюють глобальний стан напряму, що забезпечує передбачуваність.
        </li>
    </ul>
</section>

<section class="slide">
    <h2 class="shout" style="color: #fff">Дякую за увагу!</h2>
    <figure>
        <img class="cover" src="pictures/1.jpg" alt="">
    </figure>
</section>

<div class="progress"></div>

<script src="../../../core/shower.js"></script>
</body>
</html>

